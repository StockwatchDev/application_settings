{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#application_settings-version-develop","title":"application_settings - version develop","text":"<p>\"You write the dataclasses to define parameters for configuration and settings, application_settings takes care of the logic.\"</p>"},{"location":"#what-and-why","title":"What and why","text":"<p>Application_settings is a package for providing a python application or library with parameters for configuration and settings. It uses toml or json files that are parsed into dataclasses. This brings some benefits:</p> <ul> <li>Minimal work for the developer of the application / library</li> <li>Parameters are typed, which allows for improved static code analyses.</li> <li>IDEs will provide helpful hints and completion when using the parameters.</li> <li>More control over what happens when a file contains mistakes   (by leveraging the power of pydantic).</li> <li>Possibility to specify defaults when no file is found or entries are missing, i.e.,   aim for \"zeroconf\".</li> <li>Configuration parameters are read-only (i.e., changed by editing the config file); we   recommend (and support) the use of <code>toml</code> for this, which is a human-oriented,   flexible, standardardized and not overly complex format.</li> <li>Settings parameters are read-write (i.e., mostly changed via the UI of the   application); we recommend (and support) use <code>json</code> for this, an established   standardized machine-oriented format.</li> </ul> <p>Parsing is done once before or during first access and the resulting set of parameters is stored as a singleton.</p> <p>Interested? Then have a look at our quick start or dive into the full documentation.</p> <p>If you appreciate this library package, then please give us a star on Github.</p>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the terms of the MIT license.</p>"},{"location":"1-Installation/","title":"Install the package","text":"<p><code>application_settings</code> is available for pypi and can hence be installed with pip or poetry. The package is not available on conda.</p> <p>If you don't want to wait for a release and prefer to try the develop version, then you can install from our repo.</p> WindowsLinux <pre><code># From pypi with pip:\npy -m pip install -U application_settings\n\n# From pypi with poetry:\npoetry add application_settings\n\n# From the repo with pip:\npy -m pip install git+https://github.com/StockwatchDev/application_settings#develop\n\n# From the repo with poetry:\npoetry add git+https://github.com/StockwatchDev/application_settings#develop\n</code></pre> <pre><code># From pypi:\npython -m pip install -U application_settings\n\n# From pypi with poetry:\npoetry add application_settings\n\n# From the repo with pip:\npython -m pip install git+https://github.com/StockwatchDev/application_settings#develop\n\n# From the repo with poetry:\npoetry add git+https://github.com/StockwatchDev/application_settings#develop\n</code></pre> <p>We have direct dependencies on the following packages:</p> <ul> <li>loguru</li> <li>pathvalidate</li> <li>pydantic</li> <li>tomli (for python versions below 3.11)</li> <li>tomli-w</li> <li>typing-extensions (for python versions below 3.11)</li> </ul>"},{"location":"2-Defining_parameters/","title":"Defining parameters","text":"<p>This package lets you define parameters for configuration and settings. The difference between configuration and settings is as follows. <code>Config</code> is for parameters that do not change during runtime and are read from file. <code>Settings</code> are parameters that can change programmatically during runtime and are read from and saved to file for persistancy over sessions. During definition, they differ only in terms of the base classes that are used.</p> <p>The intended structure is that parameters are defined in section classes. Sections can be nested. There should be one special root section for the application, referred to as the container, that handles file storage. Config sections and Settings sections should never be mixed (i.e., do not nest a Settings section in a Config section and vice versa).</p>"},{"location":"2-Defining_parameters/#defining-non-container-sections","title":"Defining non-container section(s)","text":"<p>A section is defined by subclassing the relevant base class (<code>ConfigSectionBase</code> for config, <code>SettingsSectionBase</code> for settings) and decorating it with <code>@dataclass(frozen=True)</code>. Parameters are defined as fields of the dataclass. For a dataclass, it is mandatory to add a type hint for each field. These type hints are used also to validate the data that is read from the parameter file. If you specify a default value as well, then you prevent the occurance of an exception if the value for the parameter of concern is not found in the parameter file.</p> <p>The <code>dataclass</code> decorator provided by <code>application_settings</code> is actually an exported <code>pydantic.dataclasses.dataclass</code>, which is a drop-in replacement for a <code>dataclass</code> from the standard python library, enhanced with data validation. If you need additional dataclass functionality such as <code>fields</code> etc., you can import those from the standard library.</p> <p>Nested sections are obtained by defining fields in a section that are type hinted with the appropriate contained section class(es) and instantiated (possible only when all parameters of the nested section have default values).</p>"},{"location":"2-Defining_parameters/#defining-the-container","title":"Defining the container","text":"<p>The container is a special section that is to be the root for parametrisation of an application. It is defined likewise: by subclassing the relevant base class (<code>ConfigBase</code> for config, <code>SettingsBase</code> for settings), decorating it with <code>@dataclass(frozen=True)</code>, defining fields for parameters and nested non-root sections.</p> <p>Note that albeit settings can be changed programmatically, we still set <code>frozen=True</code> for the settings container and -sections (see also the example section below).</p>"},{"location":"2-Defining_parameters/#example","title":"Example","text":"ConfigurationSettings <pre><code>from application_settings import ConfigBase, ConfigSectionBase, dataclass\n\n@dataclass(frozen=True)\nclass MyExampleConfigSection(ConfigSectionBase):\n    \"\"\"Config section for an example\"\"\"\n\n    field1: float = 0.5\n    field2: int = 2\n\n\n@dataclass(frozen=True)\nclass MyExampleConfig(ConfigBase):\n    \"\"\"Config for an example\"\"\"\n\n    name: str = \"nice example\"\n    section1: MyExampleConfigSection = MyExampleConfigSection()\n</code></pre> <pre><code>from application_settings import SettingsBase, SettingsSectionBase, dataclass\n\n@dataclass(frozen=True)\nclass BasicSettingsSection(SettingsSectionBase):\n    \"\"\"Settings section for the basics\"\"\"\n\n    totals: int = 2\n\n\n@dataclass(frozen=True)\nclass MyExampleSettings(SettingsBase):\n    \"\"\"Settings for an example\"\"\"\n\n    name: str = \"nice name\"\n    basics: BasicSettingsSection = BasicSettingsSection()\n</code></pre>"},{"location":"3-Files/","title":"Files and file location","text":""},{"location":"3-Files/#files-for-storing-parameters","title":"Files for storing parameters","text":"<p>A Container class defines a root section and provides for behavior to load parameter values from files and, in case of settings, store updated values to files.</p> <p>Currently, two formats are supported for persistent storage of parameters: <code>toml</code> and <code>json</code>.</p> <p>The <code>toml</code> format is human-oriented, flexible, standardardized and not overly complex. It supports comments, and hence parameters can be easily documented in a toml file. However, when parameters are initialized by reading from a toml file, then changed (because it concerns settings) and subsequently written to file again for persistance, the comments will be lost. Therefore, it does not make much sense to add documenting comments to a settings file. Because config parameters are read-only, comments in a config file will not get lost and do make sense. Because of this, the default format for storing config parameters is <code>toml</code>. The name of a config file equals <code>config.toml</code> by default.</p> <p>JSON is a standardized, lightweight data-interchange format that is easy for machines to parse and generate. It is a bit less straightforward to document parameters in this format, which makes it less human-oriented than <code>toml</code>, but it is used widely for data interchange between automated systems. Because of this, the default format for storing settings parameters is <code>json</code>. The name of a settings file equals <code>settings.json</code> by default.</p> <p>The examples introduced in the previous chapter can for example be initialized with the following files.</p> <code>config.toml</code> file for the configuration example<code>settings.json</code> file for the settings example <pre><code># Use this file to set the config that you prefer by editing the file\nname = \"application specific name\"\n[section1]\n# field1 has default value 0.5\nfield1 = -0.5\n# field2 has default value 2\nfield2 = 22\n</code></pre> <pre><code>{\n    \"name\": \"the stored name\",\n    \"basics\": {\n        \"totals\": 3\n    }\n}\n</code></pre> <p>The field names of a Container class are found as:</p> <ul> <li>the root parameter names and the section names in the <code>toml</code> file</li> <li>the member names of the root object in the <code>json</code> file</li> </ul> <p>The field names of a Section class are found as:</p> <ul> <li>the parameter names inside the corresponding section in the <code>toml</code> file</li> <li>the member names of the object that is the value of the name that represents the   section in the <code>json</code> file</li> </ul> <p>The order of sections and/or fields in the file does not have to adhere to the order in which fields have been specified in the Container - or Section classes.</p> <p>Presence of sections and/or fields in the files that are not defined in the classes goes by silently.</p> <p>Fields or complete sections defined in the classes can be absent in the files as long as default values have been specified for all fields that have been left out. For more info on data validation click here</p>"},{"location":"3-Files/#location-name-and-type-of-the-file","title":"Location, name and type of the file","text":"<p>By default, the config and settings files are located in a subfolder of the home folder of the user running the application. The default name of that subfolder is provided by the <code>default_foldername()</code> method and consists of a dot, followed by a name derived from your container class: the word <code>Config</code>/<code>Settings</code> is removed, underscores are put in front of capitals (except for the first letter) and all letters are made lower case. For example, the Container class <code>MyExampleConfig</code> by default will store its config in <code>~/.my_example/config.toml</code>. And <code>MyExampleSettings</code> will default to a settings file <code>~/.my_example/settings.json</code>.</p> <p>If you want the files to be stored in a different location and/or have a different name and/or change the format, then you can use the method <code>set_filepath</code>. If you invoke this method but you have already instantiated the parameters via <code>load()</code> or <code>get()</code>, then you most likely want to reload them. You can do so by setting an argument <code>load=True</code> in <code>set_filepath</code>. If you invoke this function after parameters have been instantiated and do not set <code>load=True</code>, then a warning is printed. Example:</p> <pre><code># the next statement sets the location, name and format of the settings file\n# the argument can be eiter a string or a Path\nMyExampleSettings.set_filepath(r\"C:\\ProgramData\\testsettings.toml\")\n# the next statement loads the settings\nMyExampleSettings.load()\n# the next statement sets a new name for the settings file and reloads it\nMyExampleSettings.set_filepath(r\"C:\\ProgramData\\productionsettings.toml\", load=True)\n# the next statement resets the filepath to the default, doesn't load but generates a warning\nMyExampleSettings.set_filepath(\"\")\n</code></pre> <p>The extension of the file is used to select the format for parsing and hence has to be either <code>json</code>, <code>JSON</code>, <code>toml</code> or <code>TOML</code>.</p>"},{"location":"3-Files/#setting-the-filepath-via-command-line-arguments","title":"Setting the filepath via command-line arguments","text":"<p>A quite common scenario is to launch an application from the command-line and to specify the config file and/or settings file as argument(s). Convenience functions are available to support this using the argparse module from the standard library:</p> <ul> <li>a function <code>config_filepath_from_cli</code> is available that will define a command-line   argument that takes exactly one additional argument, namely the config filepath.   You have to specify the Config class when calling this function, and you may   pass a parser (default: the main argument parser) and your own short option   (default: <code>\"-c\"</code>) and long option (default:  <code>\"--config_filepath\"</code>) and you may   set <code>load=True</code> (default: <code>False</code>). If the option is   indeed supplied when the application is launched, then the config filepath is set using   <code>set_filepath</code> and the value for <code>load</code> is passed into this function.</li> <li>a function <code>settings_filepath_from_cli</code> is available that will define a command-line   argument that takes exactly one additional argument, namely the   settings filepath. You have to specify the Settings class when calling this function,   and you may pass a parser (default: the main argument parser) and your own short option   (default: <code>\"-s\"</code>) and long option (default:  <code>\"--settings_filepath\"</code>) and you may set   <code>load=True</code> (default: <code>False</code>). If the option is   indeed supplied when the application is launched, then the config filepath is set using   <code>set_filepath</code> and the value for <code>load</code> is passed into this function.</li> <li>a function <code>parameters_folderpath_from_cli</code> is also available and comes in handy when   you have a config file and a settings file in the same folder. This function will   define a command-line argument that takes exactly one   additional argument, namely the path of the folder that holds both files. Note that   this implies that the config- and settings file have to have the default filename. You   have to specify both the Settings class and the Config class when calling this function,   and you may pass a parser (default: the main argument parser) and your own short option   (default: <code>\"-p\"</code>) and long option (default:  <code>\"--parameters_folderpath\"</code>) and you may   set <code>load=True</code> (default: <code>False</code>). If the option is   indeed supplied when the application is launched, then the config and the settings   filepath are set using <code>set_filepath</code> and the value for <code>load</code> is passed into these   functions.</li> </ul> CLI for config filepathCLI for settings filepathCLI for common config and settings folder <pre><code>from application_settings import config_filepath_from_cli\n\n# The next line defines a cli argument \"-c\" and \"--config_filepath\"\n# and specifies that the config should be loaded when it is specified\nconfig_filepath_from_cli(MyExampleConfig, load=True)\n# the application launch with config file spec could be something like:\n# application_name -c C:\\ProgramData\\productionconfig.toml\n</code></pre> <pre><code>from application_settings import settings_filepath_from_cli\n\n# The next line defines a cli argument \"-s\" and \"--settings_filepath\"\n# and specifies that the settings should be loaded when it is specified\nsettings_filepath_from_cli(MyExampleSettings, load=True)\n# the application launch with settings file spec could be something like:\n# application_name -s C:\\ProgramData\\productionsettings.json\n</code></pre> <pre><code>from application_settings import parameters_folderpath_from_cli\n\n# The next line defines a cli argument \"-p\" and \"--parameters_folderpath\"\n# and specifies that the config and settings should be loaded when it is specified\nparameters_folderpath_from_cli(MyExampleConfig, MyExampleSettings, load=True)\n# the application launch with folder spec could be something like:\n# application_name -p C:\\ProgramData\n</code></pre> <p>It is good practice make a separate module that defines the container class and the sections and to add both the convenience function for setting the filepath via the cli and the <code>load</code> statement in that module. This may help to prevent initialization problems.</p>"},{"location":"3-Files/#handling-filenotfounderror","title":"Handling FileNotFoundError","text":"<p>When loading a parameter file, you have a choice what should happen when the parameter file is not found in the location that has been specified:</p> <ul> <li>if you <code>load(throw_if_file_not_found = False)</code>, then the <code>FileNotFoundError</code> is   catched by <code>application_settings</code>, an error message is generated and program flow is   continued by trying to instantiate the config / settings using default values. If you   have defined parameters without default values, a TypeError exception will be raised.</li> <li>if you <code>load(throw_if_file_not_found = True)</code>, then the <code>FileNotFoundError</code> exception   is thrown and the application can decide how this situation should be handled.</li> </ul> <p>The default value for <code>throw_if_file_not_found</code> is <code>False</code>, hence <code>load()</code> will not throw an exception when the parameter file is not found. Note that if you do not explicitly use <code>load</code> but rather implicitly call it via <code>get()</code> or <code>set_filepath()</code>, then this default behavior will also be obtained.</p>"},{"location":"3-Files/#sharing-parameters-over-different-configs-via-file-inclusion-with-toml","title":"Sharing parameters over different configs via file inclusion with toml","text":"<p>Another common scenario is that you work with different configurations for your application but these different configurations are partially the same. To prevent inconsistencies and config duplication, it is desirable to be able to share the common part. For this purpose, <code>application_settings</code> provides a file inclusion mechanism for <code>toml</code> configuration files.</p> <p>Above, an example of such a config file was given. Suppose now that you want to create several configurations that have a varying <code>name</code> but they will share the parametrization <code>section1</code>. Then we can put that part in a file <code>config_common.toml</code> and include that file from the different configurations.</p> <code>config.toml</code> file for the configuration example<code>config_common.toml</code> (in the same folder) <pre><code># Use this file to set the config that you prefer by editing the file\nname = \"application specific name\"\n__include__ = \"./config_common.toml\"\n</code></pre> <pre><code>[section1]\n# field1 has default value 0.5\nfield1 = -0.5\n# field2 has default value 2\nfield2 = 22\n</code></pre> <p>The file inclusion mechanism has been kept simple; the following rules apply:</p> <ul> <li>The key to use for specifying a file to include is <code>__include__</code>; hence, this key is   to be treated as a keyword and is not available as field name.</li> <li>The value can be either a single path string or an array of path strings.</li> <li>File inclusion can only be specified at the top level, not inside a section.</li> <li>File inclusion is only available for configuration, not for settings, and only for the   <code>toml</code> format.</li> <li>File inclusion can be nested, i.e., in the included <code>toml</code> file one can again specify   another file to include (albeit at the top level only).</li> <li>If the included file specifies a key that was already specified in the file that does   the inclusion, then it is disregarded and the key-value pair of the latter file is   kept.</li> </ul>"},{"location":"4-Using_parameters/","title":"Using parameters","text":""},{"location":"4-Using_parameters/#use-parameters-in-your-code","title":"Use parameters in your code","text":"<p>Parameter sections and containers are meant to be instantiated just once and be available globally for the application. Therefore, implementation has been done as follows:</p> <ul> <li>By in voking method <code>load()</code> on a parameter container class, the container and all   contained (nested) sections are instantiated with data values read   from the parameter file. The instances are stored for future access in a private module   global (a dictionary with the class id as key);</li> <li>The instance of a parameter container or section is accessed via a class method <code>get()</code>;</li> <li>The parameter value is then obtained by chaining with (the section name(s) and) the   parameter name;</li> <li>If a container has not been loaded, the first invocation of <code>get()</code> will do that   automatically. This is not the case for a section - if <code>get()</code> is invoked on a section   before any loading has been done, it will be instantiated with default values;</li> <li>A parameter container should not be instantiated directly by client code (although it   is possible to do so, e.g. for testing purposes);</li> <li>If needed, you can set the path for the parameter file before the first invocation of   <code>get()</code> (see chapter on files).</li> </ul>"},{"location":"4-Using_parameters/#changing-parameter-values","title":"Changing parameter values","text":"<p>Parameters are defined as fields of frozen dataclasses. Hence, changing parameter values by means of straightforward assignment will raise an error.</p> <p>Config parameters are meant to be read only. Changing values of such parameters has to be done by editing the config file and restarting your application or reloading the config container.</p> <p>Obviously, settings parameters can also be changed by editing the settings file and restarting the application or reloading the settings container. In addition to that, settings can be changed programmatically by calling a class method <code>update(changes: dict[str, dict[str, Any])</code>, where the argument <code>changes</code> is a dictionary in which each key is the name of a parameter that is to be updated. For updating a nested section, the key needs to hold the section name and the value should hold a dictionary with str-type keys again, etc.</p> <p>The method <code>update</code> will replace the stored settings in the private module global with an updated instance and the settings file will be updated as well. So the invocation of <code>get()</code> after <code>update</code> or application restart or reloading will return the changed parameter values.</p>"},{"location":"4-Using_parameters/#example","title":"Example","text":"ConfigurationSettings <pre><code>import MyExampleConfig\n\n# If the config file is not in the default location, then set the path first\nMyExampleConfig.set_filepath(r\"C:\\ProgramData\\MyApp\\config.toml\")\n\n# The next statement will create the config\nfield1_var: str = MyExampleConfig.get().section1.field1  # field1_var == -0.5\n# The next statement just gets that same instance\nfield2_var: int = MyExampleConfig.get().section1.field2  # field2_var == 22\n\n# After edited the config file, you can reload it (which will create a new instance)\nMyExampleConfig.load()\nfield1_var = MyExampleConfig.get().section1.field1\n\n# you cannot programmatically change config parameters\n</code></pre> <pre><code>import MyExampleSettings\n\n# If the settings file is not in the default location, then set the path first\nMyExampleSettings.set_filepath(r\"C:\\ProgramData\\MyApp\\settings.json\")\n\n# The next statement will create the settings\nname_var: str = MyExampleSettings.get().name  # name_var == \"the stored name\"\n# The next statement just gets that same instance\ntotals_var: int = MyExampleSettings.get().basics.totals  # totals_var == 3\n\n# After edited the settings file, you can reload it (which will create a new instance)\nMyExampleSettings.load()\nname_var = MyExampleSettings.get().name\n\n# change settings parameters programmatically using update\nMyExampleSettings.update({\"name\": \"updated name\", \"basics\": {\"totals\": 33}})\nprint(MyExampleSettings.get().name)  # updated name\nprint(MyExampleSettings.get().basics.totals)  # 33\n# the update has been written to file as well\nMyExampleSettings.load()\nprint(MyExampleSettings.get().name)  # updated name\n</code></pre>"},{"location":"5-Usage_in_a_library_package/","title":"Usage in a library package","text":"<p>You can use <code>application_settings</code> also to parametrize a library package:</p> <ul> <li>Define parameters in one or more Section classes (i.e., not in a Container) - best   practice is to have a single main section with possibly nested sub-sections;</li> <li>Use parameters in the code of your library by invoking class method <code>get()</code> on your   Section class(es) (see chapter on using parameters);</li> <li>The application that uses your library has to take care of loading stored values into   your parameters. This can be done in two ways:</li> <li>If the application also uses <code>application_settings</code>, it's simple; the main Section       of your library package just needs to be contained in the Container of the       application;</li> <li>If the application does not use <code>application_settings</code>, then the application       should invoke class method <code>set(data: dict[str, Any])</code> on your main Section, where       <code>data</code> holds key-value-pairs with the name of the parameter and the value.       Subsections can be set by the name of the section as key and a nested dictionary       for the subsection parameters. Note that <code>set()</code> should be invoked before any       <code>get()</code> is done.</li> </ul>"},{"location":"6-Handling_deviations/","title":"Handling deviations","text":""},{"location":"6-Handling_deviations/#handling-deviations-in-the-parameter-file","title":"Handling deviations in the parameter file","text":""},{"location":"6-Handling_deviations/#when-your-parameter-file-does-not-adhere-to-the-specified-types","title":"When your parameter file does not adhere to the specified types","text":"<p>When loading the parameter file, the values specified are coerced into the appropriate type where possible. The details of the coersion are specified in this conversion table If type coercion is not possible, then a <code>ValidationError</code> is raised (which is actually a <code>pydantic.ValidationError</code> that has been exported from our namespace). Consider the case where you would use the following config file for the <code>MyExampleConfig</code> defined before:</p> <pre><code>[section1]\nfield1 = 4\nfield2 = \"22\"\n</code></pre> <p>The <code>int</code> specified for <code>field1</code> will be coerced into a <code>float</code> value of <code>4.0</code>. The <code>str</code> specified for <code>field2</code> will be coerced into an <code>int</code> value of <code>22</code>.</p>"},{"location":"6-Handling_deviations/#when-your-parameter-file-does-not-contain-all-specified-attributes","title":"When your parameter file does not contain all specified attributes","text":"<p>If your Config or Settings has one of more sections with one or more attributes that do not have a default value, then a parameter file must be loaded and these sections and attributes must be present in the loaded parameter file. If this is not the case, a <code>TypeError</code> is raised. Attributes that have default values can be omitted from the parameter file without problems. Likewise, sections of which all attributes have default values can also be omitted without problems.</p> <p>Note that in the dataclass definitions, attributes without default value have to come before attributes with default values.</p>"},{"location":"6-Handling_deviations/#when-your-parameter-file-contains-additional-unspecified-attributes","title":"When your parameter file contains additional, unspecified attributes","text":"<p>Entries in a parameter file that are not defined in the Container or Section classes will simply be ignored silently.</p>"},{"location":"6-Handling_deviations/#more-advanced-typing-and-validation-with-pydantic","title":"More advanced typing and validation with pydantic","text":"<ul> <li>Non-standard types useful for configuration or settings, such as FilePath,   are offered, see pydantic types</li> <li>In addition, a network module is   provided by pydantic that contains types for common network-related fields</li> <li>The value of numeric types can be restricted using   pydantic constrained types</li> </ul>"},{"location":"7-Recipes/","title":"Code snippets and recipes","text":""},{"location":"7-Recipes/#logging","title":"Logging","text":""},{"location":"7-Recipes/#using-loguru","title":"Using <code>Loguru</code>","text":"<p><code>application_settings</code> makes use of the Loguru library for logging. By default, logging is disabled, hence you need to enable it to get logging output.</p> <pre><code>from loguru import logger\n\nlogger.enable(\"application_settings\")\n</code></pre> <p>The logical location for this statement is before the first invocation of <code>load</code> (or, if you do not <code>load</code> explicitly, before the first invocation of <code>get</code>).</p> <p>Note that by default <code>Loguru</code> logs to <code>stderr</code>, not <code>stdout</code> (as the standard <code>logging</code> library does). Have a look at the Loguru documentation if you want to configure the logger in the way that you want to.</p>"},{"location":"7-Recipes/#using-standard-logging","title":"Using standard <code>logging</code>","text":"<p>If you prefer to use the standard <code>logging</code> library, then you need to do two things. By default, logging is disabled, hence you need to enable it to get logging output. In addition to that, you need to propagate Loguru messages to standard logging. <code>application_settings</code> provides a convenience function <code>use_standard_logging</code> for this purpose. This function sets the propagation to the standard logger. The function has a single argument <code>enable</code> that by default is set to <code>False</code>. If a parameter <code>True</code> is provided, then the convenience function also enables logging.</p> <pre><code>from application_settings import use_standard_logging\n\nuse_standard_logging(enable=True)\n</code></pre> <p>The logical location for this statement is before the first invocation of <code>load</code> (or, if you do not <code>load</code> explicitly, before the first invocation of <code>get</code>).</p>"},{"location":"7-Recipes/#having-a-test-configuration-during-testing","title":"Having a test configuration during testing","text":"<p>During unit testing, you typically would like to have a specific test configuration and it would be a hassle to provide a file for this purpose. this especially holds true for the situation in which you have used <code>application_settings</code> to define a config section for your library package, and hence have no config container in your package that can do the file handling.</p> <p>Fortunately, there is another way, namely by using classmethod <code>set</code>. As an example, let's create a test config for <code>ExampleConfigSection</code>, (see Quick Start):</p> <pre><code># Create a (nested) dictionary that holds the test values for the relevant fields\ntest_config = {\n    \"field1\": 3.3,\n    \"field2\": -2\n}\n\n# Invoke classmethod set on the Config(Section) with this dict as parameter;\n# this will set the config singleton with the provided values\nExampleConfigSection.set(test_config)\n</code></pre> <p>The <code>test_config</code> dictionary only has to contain values for fields that have no default and for fields for which the test value differs from the default one.</p>"},{"location":"7-Recipes/#initialization-needs-to-depend-on-configuration","title":"Initialization needs to depend on configuration","text":""},{"location":"7-Recipes/#application-case","title":"Application case","text":"<p>The situation may occur that your application imports a module that holds code that is initialized during import and you want this initialization to be configurable. For example, you might want a configurable initial value for a module global variable or a class variable.</p> <p>To make this work, you need to assure that the configuration is loaded before the module of concern is imported. To make this robust, the following way of work is suggested:</p> <ul> <li>Define your configuration class(es) in a separate module;</li> <li>In the module that defines your configuration container, set <code>config_filepath_from_cli</code>   and <code>load</code> the configuration (this ensures that the config is loaded during import of   the configuration container, which will always be before usage of a config parameter);</li> <li>Start your application with the filepath to the config file as command line parameter.</li> </ul> <p>Obviously, the same approach can be followed for settings.</p> <p>To make this more clear, an example is provided in the folder <code>examples/Recipies/initialization</code>. Two configurations are defined: one that is loaded as described in the second bullet above, and one that is (wrongly) loaded with the entry point file <code>__main__</code> and not in the Config module. When running the example, it will become apparent that loading in the entry point file is too late.</p> <p>As described here, in a test setting it is generally easier to use class method <code>set</code>. Unfortunately, there is no straightforward way to invoke <code>set</code> with test values during <code>import</code>, which means that you will have to fall back to creating a test config file and loading that in the way described in this section. An example on how to do this can be found in the file <code>tests/test_initialization_import.py</code> (also part of the source distribution of this package).</p>"},{"location":"7-Recipes/#library-package-case","title":"Library package case","text":"<p>It can be that you have defined a ConfigSection for your library package and that your library also has module globals or class variables that need to be initialized with fields defined in that ConfigSection.</p> <p>The normal situation would be that your ConfigSection and the module with configurable module globals are both imported in the <code>__init__.py</code> file of your package. Unfortunately, this implies that there is no way to <code>set</code> or <code>load</code> values for your ConfigSection before the configurable module globals are initialized.</p> <p>The only way that we currently see to handle such a situation properly is the following:</p> <ul> <li>make a separate package for the ConfigSection (i.e., isolated from your libary package)</li> <li><code>import</code> that config package first, <code>set</code> (or <code>load</code>) the config values and only then   import your library package (which will also import the config package, but the   singleton has been initialized now).</li> </ul>"},{"location":"CHANGELOG/","title":"Changelog","text":""},{"location":"CHANGELOG/#changelog","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"CHANGELOG/#unreleased","title":"[Unreleased]","text":""},{"location":"CHANGELOG/#added","title":"Added","text":"<ul> <li>Added a GitHub action for PyPi deployment</li> <li>Check for presence of the dataclass decorator   (Issue #76)</li> <li>Enable file inclusion for toml config files   (Issue #67)</li> <li>Added logging   (Issue #17)</li> <li>Added a recipe for handling configurable initialization of module global variables   and class variables</li> </ul>"},{"location":"CHANGELOG/#changed","title":"Changed","text":"<ul> <li>pydantic.dataclasses.dataclass and pydantic.ValidationError now exported from our   namespace (Issue #36)</li> <li>Exceptions added to docstrings (Issue    #16)</li> <li>Upgraded pydantic to version 2.0, which has a different way of doing type conversion,   see the conversion table   (Issue #75)</li> </ul>"},{"location":"CHANGELOG/#030-2023-06-21","title":"[0.3.0] - 2023-06-21","text":""},{"location":"CHANGELOG/#added_1","title":"Added","text":"<ul> <li>Multiple versions of documentation served on Github Pages.</li> <li>You can now request a (re-) load when setting the filepath or via a method <code>load</code>.</li> <li>You can choose whether or not to throw a <code>FileNotFoundError</code> during <code>load</code>   when the parameter file is not found in the expected location   (Issue #51)</li> <li>Support for parameters in the main container (Issue   #20).</li> <li>Support for subsections (arbitrary depth) (Issue   #5).</li> <li>Sections also stored as a singleton, so that libs can define and access parameters   via their own Section (Issue    #46).</li> <li>Literal SectionTypeStr exported.</li> <li>Convenience functions to specify filepath for config and settings via command-line   [#53]</li> </ul>"},{"location":"CHANGELOG/#changed_1","title":"Changed","text":"<ul> <li>The method <code>update</code> now is a class method (breaking).</li> <li>You cannot request a reload via method <code>get</code> anymore, use separate method <code>load</code>   (breaking).</li> <li>A Container now is a specialization of a ContainerSection.</li> </ul>"},{"location":"CHANGELOG/#fixed","title":"Fixed","text":"<ul> <li>Default folder name no longer just a dot if container class is called Config or   Settings.</li> </ul>"},{"location":"CHANGELOG/#020-2023-03-19","title":"[0.2.0] - 2023-03-19","text":""},{"location":"CHANGELOG/#added_2","title":"Added","text":"<ul> <li>Files can be formatted as <code>toml</code> or <code>json</code>.</li> <li>Introduced settings, i.e., read-write parameters (where config is read-only).</li> <li>Now also useable with python 3.9.</li> <li>Documentation extended and served on Github Pages.</li> </ul>"},{"location":"CHANGELOG/#changed_2","title":"Changed","text":"<ul> <li>File path for config / settings now via <code>set_filepath()</code> and no longer as argument of   <code>get()</code>.</li> </ul>"},{"location":"CHANGELOG/#010-2023-02-13","title":"[0.1.0] - 2023-02-13","text":""},{"location":"CHANGELOG/#added_3","title":"Added","text":"<ul> <li>Loading a <code>toml</code> file.</li> <li>Initializing a dataclass with the loaded toml and storing it as a singleton.</li> <li>Default path, folder and file name.</li> <li>Specification of a config file path via argument of <code>get()</code>.</li> <li>Validation using pydantic.</li> <li>README that explains it all.</li> </ul>"},{"location":"Quick_start/","title":"Quick start","text":""},{"location":"Quick_start/#install-the-package","title":"Install the package","text":"<p><code>pip install -U application_settings</code></p>"},{"location":"Quick_start/#define-dataclasses-for-configuration-settings-parameters","title":"Define dataclasses for configuration / settings parameters","text":"<p><code>Config</code> is for read-only parameters read from file, <code>Settings</code> are read-write parameters stored to file for persistancy over sessions. During definition, they differ only in terms of the base classes that are used. Example:</p> ConfigurationSettings <pre><code>from application_settings import (\n    ConfigBase,\n    ConfigSectionBase,\n    config_filepath_from_cli,\n    dataclass,\n)\n\n@dataclass(frozen=True)\nclass MyExampleConfigSection(ConfigSectionBase):\n    \"\"\"Config section for an example\"\"\"\n\n    field1: float = 0.5\n    field2: int = 2\n\n\n@dataclass(frozen=True)\nclass MyExampleConfig(ConfigBase):\n    \"\"\"Config for an example\"\"\"\n\n    name: str = \"nice example\"\n    section1: MyExampleConfigSection = MyExampleConfigSection()\n\n\n# It is good practice to set the filepath via the command line interface\n# and load your config in the module that defines the container\nconfig_filepath_from_cli(MyExampleConfig)\nMyExampleConfig.load()\n</code></pre> <pre><code>from application_settings import (\n    SettingsBase,\n    SettingsSectionBase,\n    dataclass,\n    settings_filepath_from_cli,\n)\n\n@dataclass(frozen=True)\nclass BasicSettingsSection(SettingsSectionBase):\n    \"\"\"Settings section for the basics\"\"\"\n\n    totals: int = 2\n\n\n@dataclass(frozen=True)\nclass MyExampleSettings(SettingsBase):\n    \"\"\"Settings for an example\"\"\"\n\n    name: str = \"nice name\"\n    basics: BasicSettingsSection = BasicSettingsSection()\n\n\n# It is good practice to set the filepath via the command line interface\n# and load your settings in the module that defines the container\nsettings_filepath_from_cli(MyExampleSettings)\nMyExampleSettings.load()\n</code></pre>"},{"location":"Quick_start/#write-or-generate-the-file","title":"Write (or generate) the file","text":"<p>By default, the following files are expected for the dataclasses defined above:</p> <code>~/.my_example/config.toml</code><code>~/.my_example/settings.json</code> <pre><code># Use this file to set the config that you prefer by editing the file\nname = \"the real thing\"\n[section1]\n# field1 has default value 0.5\nfield1 = -0.5\n# field2 has default value 2\nfield2 = 22\n</code></pre> <pre><code>{\n    \"name\": \"the stored name\",\n    \"basics\": {\n        \"totals\": 3\n    }\n}\n</code></pre>"},{"location":"Quick_start/#use-parameters-in-your-code","title":"Use parameters in your code","text":"ConfigurationSettings <pre><code># You can access parameters via get()\n# If you get() MyExampleConfig before load(), it will be loaded automatically\na_variable = MyExampleConfig.get().section1.field1\nprint(f\"a_variable == {a_variable}\")  # a_variable == -0.5\n# You can also directly get() a section; but remember that the config should\n# be loaded already then (get() on a section does not automatically load())\nanother_variable = MyExampleConfigSection.get().field2\nprint(f\"another_variable == {another_variable}\")  # another_variable == 22\n\n# The only way to modify a config parameter is by editing the config file\n# or by changing the default value in the definition\n# Suppose that we edited the config file, changed the value for name to \"new name\"\n# and removed field2\n\n# You can reload a config\nMyExampleConfig.load()\nnew_variable = MyExampleConfig.get().name\nprint(f\"new_variable == {new_variable}\")  # new_variable == \"new name\"\nanother_new_variable = MyExampleConfigSection.get().field2\nprint(\n    f\"another_new_variable == {another_new_variable}\"\n)  # another_new_variable == 2\n</code></pre> <pre><code># You can access parameters via get()\n# If you get() MyExampleSettings before load(), it will be loaded automatically\na_variable = MyExampleSettings.get().name\nprint(f\"a_variable == '{a_variable}'\")  # a_variable == 'the stored name'\n# You can also directly get() a section; but remember that the settings should\n# be loaded already then (get() on a section does not automatically load())\nanother_variable = BasicSettingsSection.get().totals\nprint(f\"another_variable == {another_variable}\")  # another_variable == 3\n\n# You can update the settings:\nMyExampleSettings.update({\"basics\": {\"totals\": 33}})\n# The updated values will be written to the settings file automatically and the\n# singleton is replaced by a new instance of MyExampleSettings with the updated values\nrefreshed_totals = BasicSettingsSection.get().totals\nprint(f\"refreshed_totals == {refreshed_totals}\")  # refreshed_totals == 33\n\n# You can also edit the settings file. Suppose that we changed the value for name to\n# \"updated name\"\n\n# You can reload a setting\nMyExampleSettings.load()\nrefreshed_name = MyExampleSettings.get().name\nprint(f\"refreshed_name == '{refreshed_name}'\")  # refreshed_name == 'updated name'\n</code></pre> <p>These are the basics; a more detailed description is found in the next section (Usage) or you can take a look at the API (Reference).</p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>application_settings<ul> <li>configuring_base</li> <li>container_base</li> <li>container_section_base</li> <li>convenience</li> <li>private<ul> <li>_file_operations</li> </ul> </li> <li>settings_base</li> <li>type_notation_helper</li> </ul> </li> </ul>"},{"location":"reference/application_settings/__init__/","title":"init","text":"<p>Module for loading and retrieving parameters for configuration and settings.</p>"},{"location":"reference/application_settings/__init__/#application_settings.ConfigSectionBase","title":"ConfigSectionBase","text":"<p>             Bases: <code>ContainerSectionBase</code></p> <p>Base class for all ConfigSection classes (so that we can bound a TypeVar)</p>"},{"location":"reference/application_settings/__init__/#application_settings.ConfigSectionBase.kind_string","title":"kind_string  <code>classmethod</code>","text":"<pre><code>kind_string()\n</code></pre> <p>Return 'Config'</p> Source code in <code>src/application_settings/configuring_base.py</code> <pre><code>@classmethod\ndef kind_string(cls) -&gt; SectionTypeStr:\n    \"\"\"Return 'Config'\"\"\"\n    return \"Config\"\n</code></pre>"},{"location":"reference/application_settings/__init__/#application_settings.SettingsSectionBase","title":"SettingsSectionBase","text":"<p>             Bases: <code>ContainerSectionBase</code></p> <p>Base class for all SettingsSection classes (so that we can bound a TypeVar)</p>"},{"location":"reference/application_settings/__init__/#application_settings.SettingsSectionBase.kind_string","title":"kind_string  <code>classmethod</code>","text":"<pre><code>kind_string()\n</code></pre> <p>Return 'Settings'</p> Source code in <code>src/application_settings/settings_base.py</code> <pre><code>@classmethod\ndef kind_string(cls) -&gt; SectionTypeStr:\n    \"\"\"Return 'Settings'\"\"\"\n    return \"Settings\"\n</code></pre>"},{"location":"reference/application_settings/__init__/#application_settings.ConfigBase","title":"ConfigBase","text":"<p>             Bases: <code>ContainerBase</code></p> <p>Base class for main Config class</p>"},{"location":"reference/application_settings/__init__/#application_settings.ConfigBase.kind_string","title":"kind_string  <code>classmethod</code>","text":"<pre><code>kind_string()\n</code></pre> <p>Return 'Config'</p> Source code in <code>src/application_settings/configuring_base.py</code> <pre><code>@classmethod\ndef kind_string(cls) -&gt; SectionTypeStr:\n    \"\"\"Return 'Config'\"\"\"\n    return \"Config\"\n</code></pre>"},{"location":"reference/application_settings/__init__/#application_settings.ConfigBase.default_file_format","title":"default_file_format  <code>classmethod</code>","text":"<pre><code>default_file_format()\n</code></pre> <p>Return the default file format</p> Source code in <code>src/application_settings/configuring_base.py</code> <pre><code>@classmethod\ndef default_file_format(cls) -&gt; FileFormat:\n    \"\"\"Return the default file format\"\"\"\n    return FileFormat.TOML\n</code></pre>"},{"location":"reference/application_settings/__init__/#application_settings.ConfigBase.update","title":"update  <code>classmethod</code>","text":"<pre><code>update(changes)\n</code></pre> <p>Update and save the settings with data specified in changes</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>update not applicable for a Config class</p> Source code in <code>src/application_settings/configuring_base.py</code> <pre><code>@classmethod\ndef update(\n    cls: type[\"ConfigBase\"], changes: dict[str, dict[str, Any]]\n) -&gt; \"ConfigBase\":\n    \"\"\"Update and save the settings with data specified in changes\n\n    Raises:\n        TypeError: update not applicable for a Config class\n    \"\"\"\n\n    raise TypeError(\n        \"Configs should not be updated runtime; consider converting to settings.\"\n    )\n</code></pre>"},{"location":"reference/application_settings/__init__/#application_settings.SettingsBase","title":"SettingsBase","text":"<p>             Bases: <code>ContainerBase</code></p> <p>Base class for main Settings class</p>"},{"location":"reference/application_settings/__init__/#application_settings.SettingsBase.kind_string","title":"kind_string  <code>classmethod</code>","text":"<pre><code>kind_string()\n</code></pre> <p>Return 'Settings'</p> Source code in <code>src/application_settings/settings_base.py</code> <pre><code>@classmethod\ndef kind_string(cls) -&gt; SectionTypeStr:\n    \"\"\"Return 'Settings'\"\"\"\n    return \"Settings\"\n</code></pre>"},{"location":"reference/application_settings/__init__/#application_settings.SettingsBase.default_file_format","title":"default_file_format  <code>classmethod</code>","text":"<pre><code>default_file_format()\n</code></pre> <p>Return the default file format</p> Source code in <code>src/application_settings/settings_base.py</code> <pre><code>@classmethod\ndef default_file_format(cls) -&gt; FileFormat:\n    \"\"\"Return the default file format\"\"\"\n    return FileFormat.JSON\n</code></pre>"},{"location":"reference/application_settings/__init__/#application_settings.SettingsBase.update","title":"update  <code>classmethod</code>","text":"<pre><code>update(changes)\n</code></pre> <p>Update the settings with data specified in changes and save.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if filepath() == None</p> Source code in <code>src/application_settings/settings_base.py</code> <pre><code>@classmethod\ndef update(cls, changes: dict[str, Any]) -&gt; Self:\n    \"\"\"Update the settings with data specified in changes and save.\n\n    Raises:\n        RuntimeError: if filepath() == None\n    \"\"\"\n    return (\n        _update_settings_section(  # pylint: disable=protected-access\n            cls.get(), changes\n        )\n        ._set()\n        ._save()\n    )\n</code></pre>"},{"location":"reference/application_settings/__init__/#application_settings.config_filepath_from_cli","title":"config_filepath_from_cli","text":"<pre><code>config_filepath_from_cli(\n    config_class,\n    parser=ArgumentParser(),\n    short_option=\"-c\",\n    long_option=\"--config_filepath\",\n    load=False,\n)\n</code></pre> <p>Add a commandline option for the config file and set filepath if it is given</p> Source code in <code>src/application_settings/convenience.py</code> <pre><code>def config_filepath_from_cli(\n    config_class: type[ConfigT],\n    parser: ArgumentParser = ArgumentParser(),\n    short_option: str = \"-c\",\n    long_option: str = \"--config_filepath\",\n    load: bool = False,\n) -&gt; ArgumentParser:\n    \"\"\"Add a commandline option for the config file and set filepath if it is given\"\"\"\n    helptext: str = \"Path of the configuration file\"\n    return _parameters_filepath_from_cli(\n        config_class=config_class,\n        settings_class=None,\n        parser=parser,\n        short_option=short_option,\n        long_option=long_option,\n        helptext=helptext,\n        load=load,\n    )\n</code></pre>"},{"location":"reference/application_settings/__init__/#application_settings.settings_filepath_from_cli","title":"settings_filepath_from_cli","text":"<pre><code>settings_filepath_from_cli(\n    settings_class,\n    parser=ArgumentParser(),\n    short_option=\"-s\",\n    long_option=\"--settings_filepath\",\n    load=False,\n)\n</code></pre> <p>Add a commandline option for the settings file and set filepath if it is given</p> Source code in <code>src/application_settings/convenience.py</code> <pre><code>def settings_filepath_from_cli(\n    settings_class: type[SettingsT],\n    parser: ArgumentParser = ArgumentParser(),\n    short_option: str = \"-s\",\n    long_option: str = \"--settings_filepath\",\n    load: bool = False,\n) -&gt; ArgumentParser:\n    \"\"\"Add a commandline option for the settings file and set filepath if it is given\"\"\"\n    helptext: str = \"Path of the settings file\"\n    return _parameters_filepath_from_cli(\n        config_class=None,\n        settings_class=settings_class,\n        parser=parser,\n        short_option=short_option,\n        long_option=long_option,\n        helptext=helptext,\n        load=load,\n    )\n</code></pre>"},{"location":"reference/application_settings/__init__/#application_settings.parameters_folderpath_from_cli","title":"parameters_folderpath_from_cli","text":"<pre><code>parameters_folderpath_from_cli(\n    config_class,\n    settings_class,\n    parser=ArgumentParser(),\n    short_option=\"-p\",\n    long_option=\"--parameters_folderpath\",\n    load=False,\n)\n</code></pre> <p>Add a commandline option '--parameters_folderpath' for the common config and settings folder and set filepaths if it is given.</p> <p>Default filenames will be appended to the folderpath for config and settings.</p> Source code in <code>src/application_settings/convenience.py</code> <pre><code>def parameters_folderpath_from_cli(  # pylint: disable=too-many-arguments\n    config_class: type[ConfigT],\n    settings_class: type[SettingsT],\n    parser: ArgumentParser = ArgumentParser(),\n    short_option: str = \"-p\",\n    long_option: str = \"--parameters_folderpath\",\n    load: bool = False,\n) -&gt; ArgumentParser:\n    \"\"\"Add a commandline option '--parameters_folderpath' for the common config and settings folder and set filepaths if it is given.\n\n    Default filenames will be appended to the folderpath for config and settings.\"\"\"\n    helptext: str = \"Common path of the config file and settings file\"\n    return _parameters_filepath_from_cli(\n        config_class=config_class,\n        settings_class=settings_class,\n        parser=parser,\n        short_option=short_option,\n        long_option=long_option,\n        helptext=helptext,\n        load=load,\n    )\n</code></pre>"},{"location":"reference/application_settings/__init__/#application_settings.use_standard_logging","title":"use_standard_logging","text":"<pre><code>use_standard_logging(enable=False, fmt=None)\n</code></pre> <p>Propagate Loguru messages to standard logging</p> Source code in <code>src/application_settings/convenience.py</code> <pre><code>def use_standard_logging(  # pylint: disable=consider-alternative-union-syntax\n    enable: bool = False, fmt: Union[Formatter, None] = None\n) -&gt; None:\n    \"\"\"Propagate Loguru messages to standard logging\"\"\"\n\n    class PropagateHandler(Handler):\n        \"\"\"Handler to propagate log records to standard logging\"\"\"\n\n        def emit(self, record: LogRecord) -&gt; None:\n            \"\"\"Let the standard logger handle the log record\"\"\"\n\n            getLogger(record.name).handle(record)\n\n    handler = PropagateHandler()\n    handler.setFormatter(fmt)\n    logger.remove()  # Remove all handlers added so far, including the default one.\n    logger.add(handler, format=\"{message}\")\n\n    if enable:\n        logger.enable(__package__)\n</code></pre>"},{"location":"reference/application_settings/configuring_base/","title":"configuring_base","text":"<p>Module for handling configuration.</p>"},{"location":"reference/application_settings/configuring_base/#application_settings.configuring_base.ConfigSectionBase","title":"ConfigSectionBase","text":"<p>             Bases: <code>ContainerSectionBase</code></p> <p>Base class for all ConfigSection classes (so that we can bound a TypeVar)</p>"},{"location":"reference/application_settings/configuring_base/#application_settings.configuring_base.ConfigSectionBase.kind_string","title":"kind_string  <code>classmethod</code>","text":"<pre><code>kind_string()\n</code></pre> <p>Return 'Config'</p> Source code in <code>src/application_settings/configuring_base.py</code> <pre><code>@classmethod\ndef kind_string(cls) -&gt; SectionTypeStr:\n    \"\"\"Return 'Config'\"\"\"\n    return \"Config\"\n</code></pre>"},{"location":"reference/application_settings/configuring_base/#application_settings.configuring_base.ConfigBase","title":"ConfigBase","text":"<p>             Bases: <code>ContainerBase</code></p> <p>Base class for main Config class</p>"},{"location":"reference/application_settings/configuring_base/#application_settings.configuring_base.ConfigBase.kind_string","title":"kind_string  <code>classmethod</code>","text":"<pre><code>kind_string()\n</code></pre> <p>Return 'Config'</p> Source code in <code>src/application_settings/configuring_base.py</code> <pre><code>@classmethod\ndef kind_string(cls) -&gt; SectionTypeStr:\n    \"\"\"Return 'Config'\"\"\"\n    return \"Config\"\n</code></pre>"},{"location":"reference/application_settings/configuring_base/#application_settings.configuring_base.ConfigBase.default_file_format","title":"default_file_format  <code>classmethod</code>","text":"<pre><code>default_file_format()\n</code></pre> <p>Return the default file format</p> Source code in <code>src/application_settings/configuring_base.py</code> <pre><code>@classmethod\ndef default_file_format(cls) -&gt; FileFormat:\n    \"\"\"Return the default file format\"\"\"\n    return FileFormat.TOML\n</code></pre>"},{"location":"reference/application_settings/configuring_base/#application_settings.configuring_base.ConfigBase.update","title":"update  <code>classmethod</code>","text":"<pre><code>update(changes)\n</code></pre> <p>Update and save the settings with data specified in changes</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>update not applicable for a Config class</p> Source code in <code>src/application_settings/configuring_base.py</code> <pre><code>@classmethod\ndef update(\n    cls: type[\"ConfigBase\"], changes: dict[str, dict[str, Any]]\n) -&gt; \"ConfigBase\":\n    \"\"\"Update and save the settings with data specified in changes\n\n    Raises:\n        TypeError: update not applicable for a Config class\n    \"\"\"\n\n    raise TypeError(\n        \"Configs should not be updated runtime; consider converting to settings.\"\n    )\n</code></pre>"},{"location":"reference/application_settings/container_base/","title":"container_base","text":"<p>Base class for a container (= root section) for configuration and settings.</p>"},{"location":"reference/application_settings/container_base/#application_settings.container_base.ContainerBase","title":"ContainerBase","text":"<p>             Bases: <code>ContainerSectionBase</code>, <code>ABC</code></p> <p>Base class for Config and Settings container classes</p>"},{"location":"reference/application_settings/container_base/#application_settings.container_base.ContainerBase.default_file_format","title":"default_file_format  <code>abstractmethod</code> <code>classmethod</code>","text":"<pre><code>default_file_format()\n</code></pre> <p>Return the default file format</p> Source code in <code>src/application_settings/container_base.py</code> <pre><code>@classmethod\n@abstractmethod\ndef default_file_format(cls) -&gt; FileFormat:\n    \"\"\"Return the default file format\"\"\"\n</code></pre>"},{"location":"reference/application_settings/container_base/#application_settings.container_base.ContainerBase.default_foldername","title":"default_foldername  <code>classmethod</code>","text":"<pre><code>default_foldername()\n</code></pre> <p>Return the class name without kind_string, lowercase, with a preceding dot and underscores to seperate words.</p> Source code in <code>src/application_settings/container_base.py</code> <pre><code>@classmethod\ndef default_foldername(cls) -&gt; str:\n    \"\"\"Return the class name without kind_string, lowercase, with a preceding dot and underscores to seperate words.\"\"\"\n    if (kind_str := cls.kind_string()) == cls.__name__:\n        return f\".{kind_str.lower()}\"\n    return (\n        \".\"\n        + sub(r\"(?&lt;!^)(?=[A-Z])\", \"_\", cls.__name__.replace(kind_str, \"\")).lower()\n    )\n</code></pre>"},{"location":"reference/application_settings/container_base/#application_settings.container_base.ContainerBase.default_filename","title":"default_filename  <code>classmethod</code>","text":"<pre><code>default_filename()\n</code></pre> <p>Return the kind_string, lowercase, with the extension that fits the file_format.</p> Source code in <code>src/application_settings/container_base.py</code> <pre><code>@classmethod\ndef default_filename(cls) -&gt; str:\n    \"\"\"Return the kind_string, lowercase, with the extension that fits the file_format.\"\"\"\n    return f\"{cls.kind_string().lower()}.{cls.default_file_format().value}\"\n</code></pre>"},{"location":"reference/application_settings/container_base/#application_settings.container_base.ContainerBase.default_filepath","title":"default_filepath  <code>classmethod</code>","text":"<pre><code>default_filepath()\n</code></pre> <p>Return the fully qualified default path for the config/settingsfile</p> <p>E.g. ~/.example/config.toml. If you prefer to not have a default path then overwrite this method and return None.</p> Source code in <code>src/application_settings/container_base.py</code> <pre><code>@classmethod\ndef default_filepath(cls) -&gt; PathOpt:\n    \"\"\"Return the fully qualified default path for the config/settingsfile\n\n    E.g. ~/.example/config.toml.\n    If you prefer to not have a default path then overwrite this method and return None.\n    \"\"\"\n    return Path.home() / cls.default_foldername() / cls.default_filename()\n</code></pre>"},{"location":"reference/application_settings/container_base/#application_settings.container_base.ContainerBase.set_filepath","title":"set_filepath  <code>classmethod</code>","text":"<pre><code>set_filepath(file_path='', load=False)\n</code></pre> <p>Set the path for the file (a singleton).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>if file_path is not a valid path for the OS running the code</p> Source code in <code>src/application_settings/container_base.py</code> <pre><code>@classmethod\ndef set_filepath(cls, file_path: PathOrStr = \"\", load: bool = False) -&gt; None:\n    \"\"\"Set the path for the file (a singleton).\n\n    Raises:\n        ValueError: if file_path is not a valid path for the OS running the code\n    \"\"\"\n\n    path: PathOpt = None\n    if isinstance(file_path, Path):\n        path = file_path.resolve()\n    elif file_path:\n        if is_valid_filepath(file_path, platform=\"auto\"):\n            path = Path(file_path).resolve()\n        else:\n            raise ValueError(\n                f\"Given path: '{file_path}' is not a valid path for this OS\"\n            )\n\n    if path:\n        _ALL_PATHS[id(cls)] = path\n    else:\n        _ALL_PATHS.pop(id(cls), None)\n\n    if load:\n        cls.load()\n    else:\n        if cls._get() is not None:\n            logger.info(\n                f\"Filepath has been set the but file is not loaded into the {cls.kind_string()}.\"\n            )\n</code></pre>"},{"location":"reference/application_settings/container_base/#application_settings.container_base.ContainerBase.filepath","title":"filepath  <code>classmethod</code>","text":"<pre><code>filepath()\n</code></pre> <p>Return the path for the file that holds the config / settings.</p> Source code in <code>src/application_settings/container_base.py</code> <pre><code>@classmethod\ndef filepath(cls) -&gt; PathOpt:\n    \"\"\"Return the path for the file that holds the config / settings.\"\"\"\n    return _ALL_PATHS.get(id(cls), cls.default_filepath())\n</code></pre>"},{"location":"reference/application_settings/container_base/#application_settings.container_base.ContainerBase.load","title":"load  <code>classmethod</code>","text":"<pre><code>load(throw_if_file_not_found=False)\n</code></pre> <p>Create a new singleton, try to load parameter values from file.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>if throw_if_file_not_found == True and filepath() cannot be resolved</p> <code>TOMLDecodeError</code> <p>if FileFormat == TOML and the file is not a valid toml document</p> <code>JSONDecodeError</code> <p>if FileFormat == JSON and the file is not a valid json document</p> <code>ValidationError</code> <p>if a parameter value in the file cannot be coerced into the specified parameter type</p> Source code in <code>src/application_settings/container_base.py</code> <pre><code>@classmethod\ndef load(cls, throw_if_file_not_found: bool = False) -&gt; Self:\n    \"\"\"Create a new singleton, try to load parameter values from file.\n\n    Raises:\n        FileNotFoundError: if throw_if_file_not_found == True and filepath() cannot be resolved\n        TOMLDecodeError: if FileFormat == TOML and the file is not a valid toml document\n        JSONDecodeError: if FileFormat == JSON and the file is not a valid json document\n        ValidationError: if a parameter value in the file cannot be coerced into the specified parameter type\n    \"\"\"\n    return cls._create_instance(throw_if_file_not_found)\n</code></pre>"},{"location":"reference/application_settings/container_base/#application_settings.container_base.ContainerBase.get_without_load","title":"get_without_load  <code>classmethod</code>","text":"<pre><code>get_without_load()\n</code></pre> <p>Get has been called on a section before a load was done; handle this.</p> Source code in <code>src/application_settings/container_base.py</code> <pre><code>@classmethod\ndef get_without_load(cls) -&gt; None:\n    \"\"\"Get has been called on a section before a load was done; handle this.\"\"\"\n    logger.warning(\n        f\"{cls.kind_string()} {cls.__name__} accessed before data has been loaded; \"\n        f\"will try implicit loading with {cls.filepath()}.\"\n    )\n</code></pre>"},{"location":"reference/application_settings/container_section_base/","title":"container_section_base","text":"<p>Abstract base class for sections to be added to containers and container sections for configuration and settings.</p>"},{"location":"reference/application_settings/container_section_base/#application_settings.container_section_base.ContainerSectionBase","title":"ContainerSectionBase","text":"<p>             Bases: <code>ABC</code></p> <p>Base class for all ContainerSection classes</p>"},{"location":"reference/application_settings/container_section_base/#application_settings.container_section_base.ContainerSectionBase.kind_string","title":"kind_string  <code>abstractmethod</code> <code>classmethod</code>","text":"<pre><code>kind_string()\n</code></pre> <p>Return either 'Config' or 'Settings'</p> Source code in <code>src/application_settings/container_section_base.py</code> <pre><code>@classmethod\n@abstractmethod\ndef kind_string(cls) -&gt; SectionTypeStr:\n    \"\"\"Return either 'Config' or 'Settings'\"\"\"\n</code></pre>"},{"location":"reference/application_settings/container_section_base/#application_settings.container_section_base.ContainerSectionBase.get","title":"get  <code>classmethod</code>","text":"<pre><code>get()\n</code></pre> <p>Get the singleton; if not existing, create it. Loading from file only done for a container.</p> Source code in <code>src/application_settings/container_section_base.py</code> <pre><code>@classmethod\ndef get(cls) -&gt; Self:\n    \"\"\"Get the singleton; if not existing, create it. Loading from file only done for a container.\"\"\"\n\n    if (_the_container_or_none := cls._get()) is None:\n        # no config section has been made yet\n        cls.get_without_load()\n        # so let's instantiate one and keep it in the global store\n        return cls._create_instance()\n    return _the_container_or_none\n</code></pre>"},{"location":"reference/application_settings/container_section_base/#application_settings.container_section_base.ContainerSectionBase.get_without_load","title":"get_without_load  <code>classmethod</code>","text":"<pre><code>get_without_load()\n</code></pre> <p>Get has been called on a section before a load was done; handle this.</p> Source code in <code>src/application_settings/container_section_base.py</code> <pre><code>@classmethod\ndef get_without_load(cls) -&gt; None:\n    \"\"\"Get has been called on a section before a load was done; handle this.\"\"\"\n    # get() is called on a Section but the application\n    # has not yet created or loaded a config.\n    logger.warning(\n        f\"{cls.kind_string()} section {cls.__name__} accessed before data has been loaded; \"\n        f\"will try to load via command line parameter '--{cls.__name__}_file'\"\n    )\n</code></pre>"},{"location":"reference/application_settings/container_section_base/#application_settings.container_section_base.ContainerSectionBase.set","title":"set  <code>classmethod</code>","text":"<pre><code>set(data)\n</code></pre> <p>Create a new dataclass instance using data and set the singleton.</p> Source code in <code>src/application_settings/container_section_base.py</code> <pre><code>@classmethod\ndef set(cls, data: dict[str, Any]) -&gt; Self:\n    \"\"\"Create a new dataclass instance using data and set the singleton.\"\"\"\n    return cls(**data)._set()\n</code></pre>"},{"location":"reference/application_settings/convenience/","title":"convenience","text":"<p>Functions that can be called from the application to make life easy.</p>"},{"location":"reference/application_settings/convenience/#application_settings.convenience.config_filepath_from_cli","title":"config_filepath_from_cli","text":"<pre><code>config_filepath_from_cli(\n    config_class,\n    parser=ArgumentParser(),\n    short_option=\"-c\",\n    long_option=\"--config_filepath\",\n    load=False,\n)\n</code></pre> <p>Add a commandline option for the config file and set filepath if it is given</p> Source code in <code>src/application_settings/convenience.py</code> <pre><code>def config_filepath_from_cli(\n    config_class: type[ConfigT],\n    parser: ArgumentParser = ArgumentParser(),\n    short_option: str = \"-c\",\n    long_option: str = \"--config_filepath\",\n    load: bool = False,\n) -&gt; ArgumentParser:\n    \"\"\"Add a commandline option for the config file and set filepath if it is given\"\"\"\n    helptext: str = \"Path of the configuration file\"\n    return _parameters_filepath_from_cli(\n        config_class=config_class,\n        settings_class=None,\n        parser=parser,\n        short_option=short_option,\n        long_option=long_option,\n        helptext=helptext,\n        load=load,\n    )\n</code></pre>"},{"location":"reference/application_settings/convenience/#application_settings.convenience.settings_filepath_from_cli","title":"settings_filepath_from_cli","text":"<pre><code>settings_filepath_from_cli(\n    settings_class,\n    parser=ArgumentParser(),\n    short_option=\"-s\",\n    long_option=\"--settings_filepath\",\n    load=False,\n)\n</code></pre> <p>Add a commandline option for the settings file and set filepath if it is given</p> Source code in <code>src/application_settings/convenience.py</code> <pre><code>def settings_filepath_from_cli(\n    settings_class: type[SettingsT],\n    parser: ArgumentParser = ArgumentParser(),\n    short_option: str = \"-s\",\n    long_option: str = \"--settings_filepath\",\n    load: bool = False,\n) -&gt; ArgumentParser:\n    \"\"\"Add a commandline option for the settings file and set filepath if it is given\"\"\"\n    helptext: str = \"Path of the settings file\"\n    return _parameters_filepath_from_cli(\n        config_class=None,\n        settings_class=settings_class,\n        parser=parser,\n        short_option=short_option,\n        long_option=long_option,\n        helptext=helptext,\n        load=load,\n    )\n</code></pre>"},{"location":"reference/application_settings/convenience/#application_settings.convenience.parameters_folderpath_from_cli","title":"parameters_folderpath_from_cli","text":"<pre><code>parameters_folderpath_from_cli(\n    config_class,\n    settings_class,\n    parser=ArgumentParser(),\n    short_option=\"-p\",\n    long_option=\"--parameters_folderpath\",\n    load=False,\n)\n</code></pre> <p>Add a commandline option '--parameters_folderpath' for the common config and settings folder and set filepaths if it is given.</p> <p>Default filenames will be appended to the folderpath for config and settings.</p> Source code in <code>src/application_settings/convenience.py</code> <pre><code>def parameters_folderpath_from_cli(  # pylint: disable=too-many-arguments\n    config_class: type[ConfigT],\n    settings_class: type[SettingsT],\n    parser: ArgumentParser = ArgumentParser(),\n    short_option: str = \"-p\",\n    long_option: str = \"--parameters_folderpath\",\n    load: bool = False,\n) -&gt; ArgumentParser:\n    \"\"\"Add a commandline option '--parameters_folderpath' for the common config and settings folder and set filepaths if it is given.\n\n    Default filenames will be appended to the folderpath for config and settings.\"\"\"\n    helptext: str = \"Common path of the config file and settings file\"\n    return _parameters_filepath_from_cli(\n        config_class=config_class,\n        settings_class=settings_class,\n        parser=parser,\n        short_option=short_option,\n        long_option=long_option,\n        helptext=helptext,\n        load=load,\n    )\n</code></pre>"},{"location":"reference/application_settings/convenience/#application_settings.convenience.use_standard_logging","title":"use_standard_logging","text":"<pre><code>use_standard_logging(enable=False, fmt=None)\n</code></pre> <p>Propagate Loguru messages to standard logging</p> Source code in <code>src/application_settings/convenience.py</code> <pre><code>def use_standard_logging(  # pylint: disable=consider-alternative-union-syntax\n    enable: bool = False, fmt: Union[Formatter, None] = None\n) -&gt; None:\n    \"\"\"Propagate Loguru messages to standard logging\"\"\"\n\n    class PropagateHandler(Handler):\n        \"\"\"Handler to propagate log records to standard logging\"\"\"\n\n        def emit(self, record: LogRecord) -&gt; None:\n            \"\"\"Let the standard logger handle the log record\"\"\"\n\n            getLogger(record.name).handle(record)\n\n    handler = PropagateHandler()\n    handler.setFormatter(fmt)\n    logger.remove()  # Remove all handlers added so far, including the default one.\n    logger.add(handler, format=\"{message}\")\n\n    if enable:\n        logger.enable(__package__)\n</code></pre>"},{"location":"reference/application_settings/settings_base/","title":"settings_base","text":"<p>Module for handling settings.</p>"},{"location":"reference/application_settings/settings_base/#application_settings.settings_base.SettingsSectionBase","title":"SettingsSectionBase","text":"<p>             Bases: <code>ContainerSectionBase</code></p> <p>Base class for all SettingsSection classes (so that we can bound a TypeVar)</p>"},{"location":"reference/application_settings/settings_base/#application_settings.settings_base.SettingsSectionBase.kind_string","title":"kind_string  <code>classmethod</code>","text":"<pre><code>kind_string()\n</code></pre> <p>Return 'Settings'</p> Source code in <code>src/application_settings/settings_base.py</code> <pre><code>@classmethod\ndef kind_string(cls) -&gt; SectionTypeStr:\n    \"\"\"Return 'Settings'\"\"\"\n    return \"Settings\"\n</code></pre>"},{"location":"reference/application_settings/settings_base/#application_settings.settings_base.SettingsBase","title":"SettingsBase","text":"<p>             Bases: <code>ContainerBase</code></p> <p>Base class for main Settings class</p>"},{"location":"reference/application_settings/settings_base/#application_settings.settings_base.SettingsBase.kind_string","title":"kind_string  <code>classmethod</code>","text":"<pre><code>kind_string()\n</code></pre> <p>Return 'Settings'</p> Source code in <code>src/application_settings/settings_base.py</code> <pre><code>@classmethod\ndef kind_string(cls) -&gt; SectionTypeStr:\n    \"\"\"Return 'Settings'\"\"\"\n    return \"Settings\"\n</code></pre>"},{"location":"reference/application_settings/settings_base/#application_settings.settings_base.SettingsBase.default_file_format","title":"default_file_format  <code>classmethod</code>","text":"<pre><code>default_file_format()\n</code></pre> <p>Return the default file format</p> Source code in <code>src/application_settings/settings_base.py</code> <pre><code>@classmethod\ndef default_file_format(cls) -&gt; FileFormat:\n    \"\"\"Return the default file format\"\"\"\n    return FileFormat.JSON\n</code></pre>"},{"location":"reference/application_settings/settings_base/#application_settings.settings_base.SettingsBase.update","title":"update  <code>classmethod</code>","text":"<pre><code>update(changes)\n</code></pre> <p>Update the settings with data specified in changes and save.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if filepath() == None</p> Source code in <code>src/application_settings/settings_base.py</code> <pre><code>@classmethod\ndef update(cls, changes: dict[str, Any]) -&gt; Self:\n    \"\"\"Update the settings with data specified in changes and save.\n\n    Raises:\n        RuntimeError: if filepath() == None\n    \"\"\"\n    return (\n        _update_settings_section(  # pylint: disable=protected-access\n            cls.get(), changes\n        )\n        ._set()\n        ._save()\n    )\n</code></pre>"},{"location":"reference/application_settings/type_notation_helper/","title":"type_notation_helper","text":"<p>Defines type aliases that handle notational differences between python versions.</p>"},{"location":"reference/application_settings/private/__init__/","title":"init","text":""},{"location":"reference/application_settings/private/_file_operations/","title":"_file_operations","text":"<p>Funtions for storing dicts to and loading dicts from file.</p>"},{"location":"reference/application_settings/private/_file_operations/#application_settings.private._file_operations.FileFormat","title":"FileFormat","text":"<p>             Bases: <code>Enum</code></p> <p>File formats that are supported by application_settings</p>"},{"location":"reference/application_settings/private/_file_operations/#application_settings.private._file_operations.load","title":"load","text":"<pre><code>load(kind, path, throw_if_file_not_found)\n</code></pre> <p>Load data from the file given in path; log error or throw if not possible</p> Source code in <code>src/application_settings/private/_file_operations.py</code> <pre><code>def load(kind: str, path: PathOpt, throw_if_file_not_found: bool) -&gt; dict[str, Any]:\n    \"\"\"Load data from the file given in path; log error or throw if not possible\"\"\"\n    if _check_filepath(\n        path,\n        throw_if_invalid_path=throw_if_file_not_found,\n        throw_if_file_not_found=throw_if_file_not_found,\n        create_file_if_not_found=False,\n    ):\n        real_path = cast(Path, path)\n        if (ext := real_path.suffix[1:].lower()) == FileFormat.JSON.value:\n            return _load_json(real_path)\n        if ext == FileFormat.TOML.value:\n            if kind == \"Config\":\n                return _load_toml_with_includes(real_path, throw_if_file_not_found)\n            return _load_toml(real_path)\n    logger.warning(\n        \"Trying with default values, as loading from file is impossible. This may fail.\"\n    )\n    return {}\n</code></pre>"},{"location":"reference/application_settings/private/_file_operations/#application_settings.private._file_operations.save","title":"save","text":"<pre><code>save(path, data)\n</code></pre> <p>Save data to the file given in path; log error or throw if not possible</p> Source code in <code>src/application_settings/private/_file_operations.py</code> <pre><code>def save(path: Path, data: dict[str, Any]) -&gt; None:\n    \"\"\"Save data to the file given in path; log error or throw if not possible\"\"\"\n    if _check_filepath(\n        path,\n        throw_if_invalid_path=True,\n        throw_if_file_not_found=False,\n        create_file_if_not_found=True,\n    ):\n        if (ext := path.suffix[1:].lower()) == FileFormat.JSON.value:\n            return _save_json(path, data)\n        if ext == FileFormat.TOML.value:\n            return _save_toml(path, data)\n    return None\n</code></pre>"}]}